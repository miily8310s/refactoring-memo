# 第１０章 条件記述の単純化

- プログラムの複雑さの多くも条件記述に起因する
- 複雑な条件記述に対しては「**条件記述の分解**」
- 論理の組み合わせの明確化には「**条件記述の統合**」
- 主処理の前にいくつかの事前判定を行うケースを明確にするには「**ガード節による入れ子の条件記述の置き換え**」
- 複数の条件記述で同じ条件分岐ロジックを使っている場合には「**ポリモーフィズムによる条件記述の置き換え**」
- null のような特殊ケースのロジックが殆ど同じ場合には「**特殊ケースの導入**」で重複したコードを大量に削除できる
- 多くの条件記述を削除する際に、プログラムの状態を把握したい場合は、「**アサーションの導入**」

## 条件記述の分解

### 動機

- プログラムを複雑にする原因の中でも特に一般的なのは、複雑な条件ロジック
- 大きなブロックのコードに対しては常に、コードを分解し、それぞれを意図に沿って名付けた関数の呼び出しに置き換えることで、意図をより明確にできる
  - 条件記述の場合、条件判定と条件ごとの処理に対してこれを行うのがお勧め

### 手順

1. 条件記述および条件の各節に「関数の抽出」を適用する

### コード例

TODO: リンク貼る

## 条件記述の統合

### 動機

- 一連の条件判定があって、それぞれの条件は異なるのに、結果のアクションが同じ場合がある
- そうしたときは、and/or 演算子を使って一つの条件判定に統合する
- 条件判定のコードを統合することが重要な二つの理由
  - 1. 複数の判定をまとめることで、行っている判定が実は一つだという意図を明示できる
  - 2. 「関数の抽出」の準備になる

### 手順

1. いずれの条件判定にも副作用がないことを確認する
2. 条件判定を二つ取り出し、論理演算子を使って結合する
3. テストする
4. 条件が一つになるまで、条件判定の結合を繰り返す
5. 結果として得られた条件判定に対して「**関数の抽出**」を検討する

### コード例

TODO: リンク貼る

## ガード節による入れ子の条件記述の置き換え

### 動機

- 条件記述には二つのスタイルがある
  - then 節と else 節の両方が正常動作の場合
  - どちらか一方の節が正常動作で他方が例外的な動作の場合
- 例外的な動作に対しては、その条件が成立した際には return する。これを**ガード節**と呼ぶ
- 「ガード節による入れ子の条件記述の置き換え」の重要な点は強調の仕方にある
  - if-then-else 節を使うときは、then 節にも else 節にも同じウェイトを置く

### 手順

1. 置き換えるべき条件で最も外側のものを選択し、ガード説に変更する
2. テストする
3. 必要に応じて繰り返す
4. すべてのガード説が同じ結果を返す場合は、「条件記述の統合」を行う

### コード例

TODO: リンク貼る

## ポリモーフィズムによる条件記述の置き換え

### 動機

- 複雑な条件ロジックは、プログラミングでも特に難解な部分
- クラスとポリモーフィズムを用いると、条件ロジックに構造を与え、条件を分割できることができる
- 一揃いの方を作り、それぞれの下腿に異なる条件ロジックを処理させるやり方
  - タイプコードで分岐する switch 文を含む関数が複数存在する場合
- 条件ロジックがバリエラーションを持つ基本ケースとみなせる場合
  - 基本ケースをスーパークラスに記述する
  - 次にそれぞれのバリエーションのロジックをサブクラスに記述する

### 手順

1. ポリモーフィックな振る舞いを持たせるクラスが存在しない場合は、そのクラスと一緒に適切なインスタンを返すファクトリ関数を作成する
2. 呼び出し側のコードで、ファクトリ関数を使うようにする
3. 条件ロジックを持つ関数をスーパークラスに移動する
4. サブクラスを一つ選んで、条件別のメソッドをオーバーライドするメソッドを作成する。条件文の該当する節の内容をサブクラスのメソッドにコピーし、適合するように調整する
5. 条件ロジックの各節に対してこれを繰り返す
6. スーパークラスのメソッドにはデフォルトケースを残す。スーパークラスを抽象クラスにすべき場合は、メソッドの処理がサブクラスの責務であることを示すために、そのメソッドを抽象メソッドとして宣言するか、メソッド内でエラーを投げる

### コード例

TODO: リンク貼る

## 特殊ケースの導入

### 動機

- コード重複のよくあるケースとして、特定の値かどうかを判定し、該当する場合には同じ処理をしていることがある
- そんな状況のときは、処理を１箇所にまとめたくなる
- 「スペシャルケース」パターンは、これに対処するためのすぐれた仕組み
- 特殊ケースとして共通な振る舞いをすべて備えた要素を作成する
- 特殊ケースを表現する方法はいくつかある
  - オブジェクトからデータを読む
  - 必要な値をすべてもたせたオブジェクトリテラルを提供する

### 手順

1. 特殊ケースを判定するプロパティをオブジェクトに追加して、false を返すようにする
2. 特殊ケースを判定するプロパティだけを持つ特殊ケース用クラスを作成して、true を返すようにする
3. 特殊ケースを比較するコードに対して「関数の抽出」を行う。すべてのクライアントコードで直接比較するのをやめて、この新しい関数を使うようにする
4. 新しく作成した特殊ケース用クラスをコードに導入する。特殊ケース用オブジェクトは関数呼び出しから返すか、変換関数でオブジェクトに組み込む
5. 特殊ケースと比較する関数の本体を変更して、特殊ケースの判定用プロパティを使うようにする
6. テストする
7. 「関数群のクラスへの集約」または「関数群の変換への集約」を行って、共通な特殊ケースの処理を特殊ケース用クラスにすべて移動させる
8. 依然として特殊ケースの判定が必要な場所については、特殊ケース比較関数の呼び出しロジックに対して「関数のインライン化」を行う

### コード例

TODO: リンク貼る

## アサーションの導入

### 動機

- 多くの場合、コードの特定部分はある条件が成り立つ場合のみ機能する
- その条件が明示されず、アルゴリズムを調べない限りわからないことはよくある
  - ときにコメントに書かれている場合がある
- 前提を明示するためのすぐれたテクニックとして、アサーションを記述する方法がある
- アサーションが失敗すると、エラーログを出力する
- アサーションをすべて削除しても、プログラムは変わらず正しく動作するように記述するべき
- アサーションはコミュニケーションに有用

### 手順

1. ある条件が真であることを前提にできる場合、そのことを明示するためにアサーションを追加する

### コード例

TODO: リンク貼る
