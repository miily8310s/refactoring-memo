# 第２章 リファクタリングの原則

## リファクタリングの定義

- 「リファクタリング」という用語は名詞、もしくは動詞として使われている
- 名詞として
  - 外部から見たときの振る舞いを保ちつつ、理解や修正が簡単になるように、ソフトウェアの内部構造を変化させること
  - 名前のついたリファクタリングがこれに該当
- 動詞として
  - 一連のリファクタリングを適用して、外部から見たふるまいの変更なしに、ソフトウェア再構築すること
- リファクタリングは
  - 振る舞いを保ちつつ小さなステップを適用していくもの
  - コードを「理解や修正が容易になるように」変化させていくもの
- 個々のリファクタリングは非常に小さいステップでできている
  - その結果、コードが壊れている状態は非常に短く、いつでも中断が可能
- リファクタリング中に気がついたバグは、リファクタリング後も残っているべき

## 二つの帽子

- リファクタリングを実施する際は、作業を二つの活動に区分すべき
- 二つの活動 = 機能追加 / リファクタリング
- 機能追加を行うときは、既存のコードを変更してはいけない
- リファクタリングでは、
  - 逆に機能追加は行わないようにする
  - テストの追加はしない
- 重要なのは、どちらの帽子をかぶっているか、およびプログラミングの仕方のちょっととした違いを、常に意識しておくこと

## リファクタリングを行う理由

- リファクタリングがすべてのソフトウェアの問題を解決してくれるわけではない
- リファクタリングを行うべき理由として次のものがある
  1. ソフトウェア設計を改善する
  2. ソフトウェアを理解しやすくする
  3. バグの発見を助ける
  4. プログラミングを速める

### リファクタリングはソフトウェア設計を改善する

- リファクタリングなしでは、プログラム内部の設計（アーキテクチャ）は徐々に劣化していく
- 設計のまずいコードでは、良いものに比べ、、同じ処理をするのにも余計にコードを書くことになる
- 重複したコードを排除することは、設計を改善するための重要事項と言える

### リファクタリングはソフトウェアを理解しやすくする

- プログラミングとは、コンピュータとの対話と言える
- 何をさせたいかを正確に表現できるかがすべて
- しかし、ソースコードには、他の利用者がいることを忘れてはいけない
- プログラムを動作させることに必死で、将来の開発者のことを考えないのは問題
- 少しの時間をリファクタリングに充てるだけで、コードの目的がより伝わるようになり、実現したいことを明確に表現できるようになる

### リファクタリングはバグの発見を助ける

- コードが理解しやすいこと = バグを見つけやすい
- プログラムの構造を構造を明確にすることで、コードに対する推測が正しかったことがわかり、やがてバグを無理なく発見できるに至る

### リファクタリングはプログラミングを速める

- システムに長く携わっている開発者から、当初はすぐ開発できたけど、今では機能の追加に時間がかかるようになった話を聞く
  - 既存コードに新機能をどう適合させるかを把握する時間が、徐々に増えていく
  - 追加できても、バグが起こり、修正にさらに時間がかかるようになる
  - ついに白紙の状態から作り直せればと願うようになる
- しかし逆に新機能の追加スピードが「より早く」なっているチームもある
- この２チームの違いは、ソフトウェアの内部的な品質により生じている
- 内部の設計が優れているソフトウェアは、新たな機能を加える際にどこをどのように変更すればよいか、すぐに把握できる
- 「デザインスタミナ仮設」
  - 内部の設計を入念に行えば、ソフトウェアハイ初のためのスタミナを付けていくことができ、より長く、より速いペースで開発できる
- すぐれた設計を前もって完了しておくことは非常に難しいので、すばやく機能を追加し続けるには、リファクタリングが不可欠

## いつリファクタリングすべきか

### 準備のためのリファクタリング - 機能追加を容易にするために

- 既存のコードに機能を追加する前は、リファクタリングするのにうってつけのタイミング
- まず既存のコードを読んで、もしも構造が少し違っていたら作業はずっと簡単になるだろうと考える
- ほぼ要求を満たしそうな関数はあるが、リテラル値が埋め込まれているため期待と違う結果になっている
  - リファクタリングしない場合、リテラル値を修正した関数を別途作成する
  - しかし、これでは重複したコードができ、変更の必要が生じたら、双方を直さなければいけなくなる
  - そしてコピー・ペーストで対応できなくなってしまう
- そこでリファクタリングの帽子をかぶり、「**パラメータによる関数の統合**」を行う
- 変えたい部分を引数にして関数を呼べばよいだけになる
- 同じことはバグ修正にも当てはまる
- ３箇所にコピーされたバグを含んだコードをまず１つにまとめてしまうほうが、修正はずっと簡単になる

### 理解のためのリファクタリング - コードをわかりやすくするために

- コードに手を加える前は、まず何を行っているかを理解する必要がある
- コードが何しているか理解しづらいときには、ひと目でわかるようにリファクタリングできないかを考える
- 手始めに、理解のためのリファクタリングを細かく行うようにする
  - 変数名を修正して、それが何を表すのか理解できるようにする
  - 長い関数を小さく分割する
- コードを調べる際にリファクタリングを行うと、手を加えなければ見失っていたことについても、理解が深まる

### ゴミ拾いのためのリファクタリング

- コードが何をしているかはわかるものの、書き方が今ひとつというときに行うリファクタリングがある
- 必要以上に入り組んだロジックや、パラメータを輪合うようにすれば一本化できるはずの、ほぼ同じ関数を見つけたりする
- 今取り掛かっているタスクに直接関係ないことに時間は奪われたくない
- しかし将来の変更要求があったときに、邪魔になるであろうゴミを放置したくない
- 修正に手こずりそうなときは、メモをのこしておいて、目下のタスクが終わった後で取り掛かるようにする
- ダメなコードを見かけるたびに少しずつ改善をしていけば、やがて問題はなくなっていく

### 計画されたリファクタリングと、機に応じたリファクタリング

- ひどいコードを見つけたときにリファクタリングしなければいけないのは確か
- しかし既存の素晴らしいコードもまた、リファクタリングが必要
- 昨日までは正しかったものの、今日加える新異能によって、妥当ではなくなるかもしれない
- きれいなコードが保たれていれば、見直すべきときも、簡単にリファクタリングできる

### 長期のリファクタリング

- ほとんどのリファクタリングは数分、長くても数時間で終わるもの
- しかしときには開発チームが１周間かけて取り組まなければならないような巨大なリファクタリングもある
  - 現在のライブラリを、まったく新しいものに置き換えなければならないとき
  - コードのある部分をコンポーネント化するような場合
- そうした場合でもチームをリファクタリングに専念させるのはお勧めできない
- 直近の数週間で問題を徐々に解決していくことにチームで合意するのが有効なやり方

### コードレビュー時のリファクタリング

- リファクタリングは、他人の書いたコードをレビューするにも役立つ
  - 多くの意見が実装される
- コードを書いた人が同席していると、コードのコンテキストを伝えることができ、レビューの糸も十分理解できるようになる
- 筆者的にはコードの作成者と並んで一対一になりコードをレビューしてリファクタリングも行う形（=「ペアプログラミング」）が最もうまくいく

### 管理者を説得するには

- 管理者がリファクタリングのことを、過去のエラーの修正あるいは価値を産まない作業をしているだけと思いこんでいる開発現場も見受けられる
- 管理者が技術に詳しく、デザインスタミナ仮設を理解できているなら、リファクタリングの説明はそれほど難しくない
- もちろん管理者によっては、逆に理解できないこともある
- こうした管理者の場合は「彼らには黙ってリファクタリングする」

### リファクタリングを避けるとき

- 実際にはリファクタリングの価値がない場合もある
- 混沌としたコード見かけたとしても、修正の必要がなければ、リファクタリングする必要はない
- どのようにして動いているのか理解しなければならない状況になったときに初めて、リファクタリングの利点が出てくる
- 最初から書き直した方がリファクタリングするより簡単なときもある

## リファクタリングの問題点

- リファクタリングにも問題点はある
- どのような問題が起こり得て、どのように対応できるかを理解することが重要

### 新機能の実装が遅くなる
