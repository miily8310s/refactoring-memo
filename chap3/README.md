# 第３章 コードの不吉な臭い

- 本章ではいつリファクタリングするか迷ったときの指針となる臭いの種類、その対処法となるリファクタリングを解説

## 不可思議な名前

- 明快なコードにするために最も重要なのは、適切な名前付け
  - 関数、モジュール、変数、クラスなどの名前
- 悲しいことに、名前付けは、プログラミングで最も難しいこと二つのうちの一つ
- 名前の変更がリファクタリングで最も行われる作業

### 対処するリファクタリング

- 「**関数宣言の変更**」
- 「**変数名の変更**」
- 「**フィールド名の変更**」

## 重複したコード

- 同じ構造のコードが２箇所以上にある場合、一つにまとめることができると、より良いプログラムになる
- 重複したコードの修正時には、重複部分をもれなく見つけ、すべてに同様の修正を施す必要がある

### 対処するリファクタリング

- 「**関数の抽出**」
  - 抽出したメソッドを元のメソッド本体から呼ぶようにする
- 「**ステートメントのスライド**」
  - 似てはいるが完全に同じではない場合がある
  - コードを整え、似た箇所を寄せておくと抽出しやすくなる
- 「**メソッドの引き上げ**」
  - 共通の親クラス配下のサブクラス間に重複したコードがある場合

## 長い関数

- 長く充実した人生を送るのは、短い関数を持ったプログラム
- 最もお勧めの方法は、関数名をわかりやすくすること
  - 関数名が適切であれば、内部の実装を見なくとも先に読みすすめていける
  - コメントが必要だと感じたとき、代わりにわかりやすい名前がついた関数に分割してしまうべき
  - そのコードが「意図」を示した名前をつけるようにする

### 対処するリファクタリング

- 「**関数の抽出**」
  - 関数を短くするための作業の 99％を占める
  - 巨大`switch`文に対しても有効
- 「**問い合わせによる一時変数の置き換え**」
  - 一時変数を減らす
- 「**パラメータオブジェクトの導入**」
- 「**オブジェクトそのものの受け渡し**」
  - 長いパラメータリストをスリムに
- 「**コマンドによる関数の置き換え**」
  - 上記 4 つの方法を試しても一時変数やパラメータが残っている場合に
- 「**条件記述の分解**」
  - 条件分岐やループの抽出に
- 「**ポリモーフィズムによる条件記述の置き換え**」
  - 同じ条件で分岐している`switch`文が複数あった場合
- 「**ループの分離**」
  - ループは、ループ部分とループ内部のコードを抽出して、独立した関数にできる

## 長いパラメータリスト

### 対処するリファクタリング

- 「**問い合わせによるパラメータの置き換え**」
  - パラメータで渡されるオブジェクトに問い合わせることで、パラメータリスト中の他のデータを取得できる場合がある
  - その場合は、その分のパラメータを削除できる
- 「**オブジェクトそのもの受け渡し**」
  - 元々のデータ構造を渡してしまう
- 「**パラメータオブジェクトの導入**」
  - 複数のパラメータが常に一緒に渡される場合に
- 「**フラグパラメータの削除**」
  - パラメータが振る舞いを変えるためのフラグとして使われている場合に
- 「**関数群のクラスへの集約**」
  - クラスはパラメータの数を減らすためのすぐれた手段
  - 複数の関数群が、パラメータで渡される値を共有しているときに特に有効
  - この共通の値をフィールドとして定義する

## グローバルなデータ

- グローバルなデータは、今でも遭遇する可能性のある、強烈な臭気の一つ
- コードベースのどこからでも変更できてしまい、どこで変更が行われたかを知るすべもない

### 対処するリファクタリング

- 「**変数のカプセル化**」
  - プログラムのあらゆる箇所の汚染にさらされたデータを見つけたときに
  - 少なくとも関数経由でのアクセスにすることで、いつ値を変更しているのかが突き止めやすくなり、制御できるようになる

## 変更可能なデータ

- データの変更はしばしばよきせぬ結果や、厄介なバグを引き起こす
- 値が変わる条件がまれにしかない場合、特に見つけづらくなる
- いつでも計算で導出できるのに変更可能になっているデータも、かなり不吉

### 対処するリファクタリング

- 「**変数のカプセル化**」
  - すべての値の変更が特定の関数を通してのみ起こるようにできる
- 「**変数の分離**」
  - 一つの変数が別の事項を表すために使われているとき
  - 同法を分離し、危険な変更を避けるようにする
- 「**ステートメントのスライド**」
- 「**関数の抽出**」
  - 更新を行う箇所からそれ以外のロジックをできるだけ取り除き、更新処理のコードと副作用のないコードを分離する
- 「**問い合わせと更新の分離**」
  - API の実装箇所のみ
- 「**setter の削除**」
  - `setter`を読んでいる側を特定してから、変数のスコープを狭める
- 「**問い合わせによる導出変数の置き換え**」
  - いつでも計算で導出できるのに変更可能になっているデータを削除
- 「**関数群のクラスへの集約**」
- 「**関数群の変換への集約**」
  - 変数の値を変更しなければ行けない箇所を減らす
- 「**参照から値への変更**」
  - 内部構造にデータを含んでいる変数がある場合
  - 部分的に内部の値を修正するより、全体を入れ替えてしまうのが好ましい

## 変更の偏り

- 「変更の偏り」：一つのモジュールが異なる目的のために異なる方法で変更される状況
  - 例）同一モジュールに対して「データベースが追加されるたびにいつもこの三つのメソッドを修正しなければいけない」状況
- 変更しなければいけないときは、変更箇所を一つに特定して、そこだけを変えるようにしたい
- これがうまくいかないとき、「変更の偏り」の臭いを味わうことになる

### 対処するリファクタリング

- 「**フェーズの分離**」
  - 二つの処理が順番に現れるのが自然な場合
    - 例）データベースからデータを取り出してから、金融処理に利用する場合
  - 両者を取り持つデータ構造を明確に定めて分離するとよい
- 「**関数の移動**」
  - 呼び出し順序が前後する場合
  - 適切なモジュールを新規に作成し、処理を独立させる
- 「**関数の抽出**」
  - 関数が二つの異なる処理を内部でごちゃまぜに行っている
  - 移動の前に処理を分離させる
- 「**クラスの抽出**」
  - モジュールがクラスの場合

## 変更の分散

- 「変更の分散」：変更の行うたびにあちこちのモジュールが少しずつ書き換わる場合
- 変更すべき箇所が全体に広がると探すのが難しくなり、重要な変更を実装し忘れる場合も出てくる

### 対処するリファクタリング

- 「**フェーズの分離**」
- 「**関数の移動**」
  - 変更部分が一つのモジュールにまとめあげるようにする
- 「**関数群のクラスへの集約**」
  - 似たようなデータ構造を扱う一連の関数群がある場合
- 「**関数群の変換への集約**」
  - データ構造を変換したり、情報を付加したりする関数群がある場合
- 「**フェーズの分離**」
  - データを消費するロジックのために、共通の関数群が出力を組み合わせていける場合
- 「**関数のインライン化**」
- 「**クラスのインライン化**」
  - 不適切に分割されたロジックをまとめる

## 特性の横恋募

- 例）あるモジュールの関数が、内部のモジュールよりも、外部のモジュールの関数やデータ構造とやり取りしている
- プログラムのモジュール化では、内部でのやりとりを最大に、外部とのやりとりは最小にすべき

### 対処するリファクタリング

- 「**関数の移動**」
  - たいていはこれで解決する
  - 他のオブジェクトの`get`メソッドを何度も呼び出している関数に対して有効
- 「**関数の抽出**」
  - 関数内の一部のロジックだけが、こうした横恋募を行っている場合がある
  - その場合はまずこれを行う、その後に「**関数の移動**」を実施

## データの群れ

- 数個のデータがつるんで、クラスのフィールドやメソッドのシグニチャ（※メソッド名、引数の型、引数の数）など、さまざまな箇所に現れることがある
- こうした群れをなしたデータは、同じ箇所にまとめるべき

### 対処するリファクタリング

- 「**クラスの抽出**」
  - データの群れをオブジェクトに発展させる
- 「**パラメータオブジェクトの導入**」
- 「**オブジェクトそのものの受け渡し**」
  - これでパラメータの数が減り、メソッド呼び出しが単純になる

## 基本データ型への執着

- 多くのプログラマは、大正としているドメインに役立つ、貨幣などの基本的な型を導入するのを嫌がる傾向がある
- この種の臭いは、文字列で顕著

### 対処するリファクタリング

- 「**オブジェクトによるプリミティブの置き換え**」
  - 個々のデータに対して行う
- 「**サブクラスによるタイプコードの置き換え**」
- 「**ポリモーフィズムによる条件記述の置き換え**」
  - データの振る舞いを変えるための単純なタイプコードのとき
  - 上から順に実行
- 「**クラスの抽出**」
- 「**パラメータオブジェクトの導入**」
  - 基本データ型の同じ集まりが何度もコード中に現れているなら、「データの群れ」
  - 上記によってデータをまとめる

## 重複したスイッチ文

- 以前に比べると、`switch`文は安全になった
- 今後問題なのは、`switch/case`文、`if/else`文のかたちで、コードのさまざまな箇所に同じ条件分岐ロジックが書かれている場合

### 対処するリファクタリング

- 「**ポリモーフィズムによる条件記述の置き換え**」

## ループ

- 以前に比べると、あまり重要ではなくなってきた

### 対処するリファクタリング

- 「**パイプラインによるループの置き換え**」
  - filter/map といったパイプライン操作を使うべき

## 怠け者の要素

- 開発者はプログラムに構造を加えていく
- ただし、構造自体が不要になることもある
  - かつて役立っていたが、リファクタリングで不要になったもの
  - メソッドが一つしかないもの

### 対処するリファクタリング

- 「**関数のインライン化**」
- 「**クラスのインライン化**」
  - 不要な要素を葬り去る
- 「**クラス回数の平坦化**」
  - 継承がある場合に

## 疑わしき一般化

- 現在は必要としていない仕掛けが存在する場合がある
- これらは無用なら削除すべき

### 対処するリファクタリング

- 「**クラス階層の平坦化**」
  - 大した働きをしていない抽象クラスを削除
- 「**関数のインライン化**」
- 「**クラスのインライン化**」
  - 意味のない委譲を削除
- 「**関数宣言の変更**」
  - 未使用のパラメータを持つ関数から、パラメータを削除

## 一時的属性

- インスタンス変数の値が、特定の状況でしか設定されないクラスに出会うことがある
- 通常、オブジェクトはすべての属性を必要だと考えるので、非常に理解しづらくなる

### 対処するリファクタリング

- 「**クラスの抽出**」
  - 変数の居場所を作る
- 「**関数の移動**」
  - その属性を扱っているコード軍を、新たなクラスとしてまとめる
- 「**特殊ケースの導入**」
  - 変数が無効なときのための代替クラスを用意すると、条件文のコードを排除できる

## メッセージの連鎖

- クライアントがあるオブジェクトにメッセージを贈り、受けっとオブジェクトがさらに別のオブジェクトにメッセージを送り、
  それがまた別のオブジェクトへメッセージを送るといった、メッセージの過剰な連鎖が起こることがある
- この形でオブジェクトの連鎖を行うと、連鎖する過程の構造にクライアントが強く依存することになる
- 中間のオブジェクトの関連が変わるたびに、クライアントが影響を受けてしまう

### 対処するリファクタリング

- 「**委譲の隠蔽**」
  - 上記の場合、使うことができる
- 「**関数の抽出**」
- 「**関数の移動**」
  - 連鎖を短くまとめる

## 仲介人

- オブジェクト指向にはカプセル化がある
- これによって、内部の詳細を外観から一切見えないようにできる
- ところが、権限の委譲が過剰となり、メソッドの大半が別のオブジェクトに委譲しているだけのクラスを見ることもある

### 対処するリファクタリング

- 「**仲介人の除去**」
  - 本当に仕事をするオブジェクトに直接処理させる
- 「**関数のインライン化**」
  - 仲介人メソッドが僅かな場合は、呼び出し側にそれを埋め込む

## インサイダー取引

- モジュール間でのデータのやりとりには、必然的なものもある
- ただし、そうしたやり取りは最小限にとどめ、把握できるようにすべき

### 対処するリファクタリング

- 「**関数の移動**」
- 「**フィールドの移動**」
  - こっそりやりとりしているモジュールがあった場合、やり取りさせないようにする
- 「**委譲の隠蔽**」
  - モジュールが共通の内容を持っていた場合、モジュールを仲介人にすることができる
- 「**委譲によるサブクラスの置き換え**」
- 「**委譲によるスーパークラスの置き換え**」
  - サブクラスがスーパークラスに依存しきっている場合がある
  - サブクラスもしくはスーパークラスを隔離させる

## 巨大なクラス

- １つのクラスの責務が大きい場合、大抵はインスタンスヘンスの持ちすぎになっている
- こうした状況になっていると、重複したコードが存在する可能性も高くなる

### 対処するリファクタリング

- 「**クラスの抽出**」
  - まず、いくつかの変数をひとまとめにする
- 「**スーパークラスの抽出**」
- 「**サブクラスによるタイプコードの置き換え**」
  - 新しく出来たコンポーネントが継承でまとまりそう場合に

## クラスのインタフェース不一致

- クラスを使うことで得られる最大の利点として、必要に応じて、他の置き換えが可能になる
- しかしこれがうまくいくのは、インタフェースが同じ場合

### 対処するリファクタリング

- 「**関数宣言の変更**」
  - インタフェースをあわせる
- 「**関数の移動**」
  - 上記でうまく行かない場合、インタフェースが同じになるように振る舞いを適切なクラスに配置するようにする
- 「**スーパークラスの抽出**」
  - 移動に伴って重複したコードが発生した場合

## データクラス

- 属性と get、set 以外に何も持たないクラスに出会うことがある
- こうしたクラスは単なるデータ保持用で、他のクラスから過剰にアクセスされがち

### 対処するリファクタリング

- 「**レコードのカプセル化**」
  - なるべく速い段階で行う
- 「**setter の削除**」
  - 変更されては都合の悪い属性に対して
- 「**関数の移動**」
  - get または set メソッドが、他のクラスのどこで使われているかを確認
  - データクラスに振る舞いを移せないかを確認
- 「**関数の抽出**」
  - 関数全体で移せない場合
  - 移動できる部分だけ移動する

## 相続拒否

- サブクラスは親の属性と操作を継承するのが普通
- しかし、それらが必要としていない場合がある
- この場合、継承階層が間違っているのが伝統的な見方

### 対処するリファクタリング

- 「**メソッドの押し下げ**」
- 「**フィールドの押し下げ**」
  - 兄弟となるクラスを新たに作成して、使われていないコード兄弟コードへ移す
- 「**委譲によるサブクラスの置き換え**」
- 「**委譲によるスーパークラスの置き換え**」
  - サブクラスがスーパークラスの振る舞いを継承するけれども、インターフェイスは必要としていない場合に

## コメント

- コメントはむしろ良い香り
- コメントが非常に丁寧に書かれているのは、実はわかりにくいコードを補うためだった
- コメントは、不吉な臭いの予兆として考えることができる
- また、処理の説明だけでなく以下のメモとしても使える
  - よくわからない事項の説明
  - なぜこのような処理を選択したかの説明

### 対処するリファクタリング

- 「**関数の抽出**」
  - コード内の処理の一部を説明するのにコメントが必要な場合
- 「**関数宣言の変更**」
  - 関数がすでに細かく抽出されているが、それでも処理がわかりにくい場合
  - 名前の変更を試みる
- 「**アサーションの導入**」
  - システムが特定の状態を必要としていることをルールによって明確に表現したい場合
