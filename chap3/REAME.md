# 第３章 コードの不吉な臭い

- 本章ではいつリファクタリングするか迷ったときの指針となる臭いの種類、その対処法となるリファクタリングを解説

## 不可思議な名前

- 明快なコードにするために最も重要なのは、適切な名前付け
  - 関数、モジュール、変数、クラスなどの名前
- 悲しいことに、名前付けは、プログラミングで最も難しいこと二つのうちの一つ
- 名前の変更がリファクタリングで最も行われる作業

### 対処するリファクタリング

- 「**関数宣言の変更**」
- 「**変数名の変更**」
- 「**フィールド名の変更**」

## 重複したコード

- 同じ構造のコードが２箇所以上にある場合、一つにまとめることができると、より良いプログラムになる
- 重複したコードの修正時には、重複部分をもれなく見つけ、すべてに同様の修正を施す必要がある

### 対処するリファクタリング

- 「**関数の抽出**」
  - 抽出したメソッドを元のメソッド本体から呼ぶようにする
- 「**ステートメントのスライド**」
  - 似てはいるが完全に同じではない場合がある
  - コードを整え、似た箇所を寄せておくと抽出しやすくなる
- 「**メソッドの引き上げ**」
  - 共通の親クラス配下のサブクラス間に重複したコードがある場合

## 長い関数

- 長く充実した人生を送るのは、短い関数を持ったプログラム
- 最もお勧めの方法は、関数名をわかりやすくすること
  - 関数名が適切であれば、内部の実装を見なくとも先に読みすすめていける
  - コメントが必要だと感じたとき、代わりにわかりやすい名前がついた関数に分割してしまうべき
  - そのコードが「意図」を示した名前をつけるようにする

### 対処するリファクタリング

- 「**関数の抽出**」
  - 関数を短くするための作業の 99％を占める
  - 巨大`switch`文に対しても有効
- 「**問い合わせによる一時変数の置き換え**」
  - 一時変数を減らす
- 「**パラメータオブジェクトの導入**」
- 「**オブジェクトそのものの受け渡し**」
  - 長いパラメータリストをスリムに
- 「**コマンドによる関数の置き換え**」
  - 上記 4 つの方法を試しても一時変数やパラメータが残っている場合に
- 「**条件記述の分解**」
  - 条件分岐やループの抽出に
- 「**ポリモーフィズムによる条件記述の置き換え**」
  - 同じ条件で分岐している`switch`文が複数あった場合
- 「**ループの分離**」
  - ループは、ループ部分とループ内部のコードを抽出して、独立した関数にできる

## 長いパラメータリスト

### 対処するリファクタリング

- 「**問い合わせによるパラメータの置き換え**」
  - パラメータで渡されるオブジェクトに問い合わせることで、パラメータリスト中の他のデータを取得できる場合がある
  - その場合は、その分のパラメータを削除できる
- 「**オブジェクトそのもの受け渡し**」
  - 元々のデータ構造を渡してしまう
- 「**パラメータオブジェクトの導入**」
  - 複数のパラメータが常に一緒に渡される場合に
- 「**フラグパラメータの削除**」
  - パラメータが振る舞いを変えるためのフラグとして使われている場合に
- 「**関数群のクラスへの集約**」
  - クラスはパラメータの数を減らすためのすぐれた手段
  - 複数の関数群が、パラメータで渡される値を共有しているときに特に有効
  - この共通の値をフィールドとして定義する

## グローバルなデータ

- グローバルなデータは、今でも遭遇する可能性のある、強烈な臭気の一つ
- コードベースのどこからでも変更できてしまい、どこで変更が行われたかを知るすべもない

### 対処するリファクタリング

- 「**変数のカプセル化**」
  - プログラムのあらゆる箇所の汚染にさらされたデータを見つけたときに
  - 少なくとも関数経由でのアクセスにすることで、いつ値を変更しているのかが突き止めやすくなり、制御できるようになる

## 変更可能なデータ

- データの変更はしばしばよきせぬ結果や、厄介なバグを引き起こす
- 値が変わる条件がまれにしかない場合、特に見つけづらくなる
- いつでも計算で導出できるのに変更可能になっているデータも、かなり不吉

### 対処するリファクタリング

- 「**変数のカプセル化**」
  - すべての値の変更が特定の関数を通してのみ起こるようにできる
- 「**変数の分離**」
  - 一つの変数が別の事項を表すために使われているとき
  - 同法を分離し、危険な変更を避けるようにする
- 「**ステートメントのスライド**」
- 「**関数の抽出**」
  - 更新を行う箇所からそれ以外のロジックをできるだけ取り除き、更新処理のコードと副作用のないコードを分離する
- 「**問い合わせと更新の分離**」
  - API の実装箇所のみ
- 「**setter の削除**」
  - `setter`を読んでいる側を特定してから、変数のスコープを狭める
- 「**問い合わせによる導出変数の置き換え**」
  - いつでも計算で導出できるのに変更可能になっているデータを削除
- 「**関数群のクラスへの集約**」
- 「**関数群の変換への集約**」
  - 変数の値を変更しなければ行けない箇所を減らす
- 「**参照から値への変更**」
  - 内部構造にデータを含んでいる変数がある場合
  - 部分的に内部の値を修正するより、全体を入れ替えてしまうのが好ましい

## 変更の偏り

- 「変更の偏り」：一つのモジュールが異なる目的のために異なる方法で変更される状況
  - 例）同一モジュールに対して「データベースが追加されるたびにいつもこの三つのメソッドを修正しなければいけない」状況
- 変更しなければいけないときは、変更箇所を一つに特定して、そこだけを変えるようにしたい
- これがうまくいかないとき、「変更の偏り」の臭いを味わうことになる

### 対処するリファクタリング

- 「**フェーズの分離**」
  - 二つの処理が順番に現れるのが自然な場合
    - 例）データベースからデータを取り出してから、金融処理に利用する場合
  - 両者を取り持つデータ構造を明確に定めて分離するとよい
- 「**関数の移動**」
  - 呼び出し順序が前後する場合
  - 適切なモジュールを新規に作成し、処理を独立させる
- 「**関数の抽出**」
  - 関数が二つの異なる処理を内部でごちゃまぜに行っている
  - 移動の前に処理を分離させる
- 「**クラスの抽出**」
  - モジュールがクラスの場合

## 変更の分散

- 「変更の分散」：変更の行うたびにあちこちのモジュールが少しずつ書き換わる場合
- 変更すべき箇所が全体に広がると探すのが難しくなり、重要な変更を実装し忘れる場合も出てくる

### 対処するリファクタリング

- 「**フェーズの分離**」
- 「**関数の移動**」
  - 変更部分が一つのモジュールにまとめあげるようにする
- 「**関数群のクラスへの集約**」
  - 似たようなデータ構造を扱う一連の関数群がある場合
- 「**関数群の変換への集約**」
  - データ構造を変換したり、情報を付加したりする関数群がある場合
- 「**フェーズの分離**」
  - データを消費するロジックのために、共通の関数群が出力を組み合わせていける場合
- 「**関数のインライン化**」
- 「**クラスのインライン化**」
  - 不適切に分割されたロジックをまとめる

## 特性の横恋募

- 例）あるモジュールの関数が、内部のモジュールよりも、外部のモジュールの関数やデータ構造とやり取りしている
- プログラムのモジュール化では、内部でのやりとりを最大に、外部とのやりとりは最小にすべき

### 対処するリファクタリング

- 「**関数の移動**」
  - たいていはこれで解決する
  - 他のオブジェクトの`get`メソッドを何度も呼び出している関数に対して有効
- 「**関数の抽出**」
  - 関数内の一部のロジックだけが、こうした横恋募を行っている場合がある
  - その場合はまずこれを行う、その後に「**関数の移動**」を実施

## データの群れ

TODO:

- 例）あるモジュールの関数が、内部のモジュールよりも、外部のモジュールの関数やデータ構造とやり取りしている
- プログラムのモジュール化では、内部でのやりとりを最大に、外部とのやりとりは最小にすべき

### 対処するリファクタリング

- 「**関数の移動**」
  - たいていはこれで解決する
  - 他のオブジェクトの`get`メソッドを何度も呼び出している関数に対して有効
- 「**関数の抽出**」
  - 関数内の一部のロジックだけが、こうした横恋募を行っている場合がある
  - その場合はまずこれを行う、その後に「**関数の移動**」を実施
