# 第８章 特性の移動

- ここまで消化してきたリファクタリングは、プログラム要素の作成、削除、および名前の変更に関するもの
- リファクタリングのもう一つの重要な役割は、要素をコンテキスト間で移動させること
- 関数を移動させる
  - クラスやモジュール間では「**関数の移動**」
  - フィールドは「**フィールドの移動**」
- 個々のステートメントの移動
  - 「**ステートメントの関数内への移動**」で関数外から関数内に移動
  - 「**ステートメントの呼び出し側への移動**」で関数の外に移動
  - 「**ステートメントのスライド**」で関数内で移動
  - 「**関数呼び出しによるインラインコードの置き換え**」
    - 既存の関数と同じ処理をしているステートメントで重複を解除する
- ループに対して適用する
  - 「**ループの分離**」でループの仕事を一つだけにする
  - 「**パイプラインによるループの置き換え**」でループを完全に取り除く
- 「**デッドコードの削除**」

## 関数の移動

### 動機

- すべての関数はなんらかのコンテキストに置かれ、通常はなんらかのモジュールの形式を取る
- 関数を移動する最も直接的な理由は、その関数が存在するコンテキストの要素よりも他のコンテキストの要素を多く参照している場合
- 移動によって、関数をそれらの要素と一緒にすると、カプセル化が改善することがよくある
- 呼び出し元が存在する場所や、次の拡張時に呼び出したい場所に関数を移動することがある
- 関数の移動の判断はたいてい困難を伴う
  - その判断には、その関数の現在のコンテキストと移動先候補のコンテキストを調べる
- 新しいコンテキストが必要になるケースは多い
  - 関数群のクラスへの集約、クラスの抽出によって新しく作成する

### 手順

1. 移動対象の関数が現在のコンテキストで使用しているプログラム要素をすべて調べる。それらも移動するかも検討する
2. 選択した関数がポリモーフィックなメソッドか確認する
3. 関数を移動先のコンテキストにコピーする。新居となる移動先に関数が適合するように調整する
4. 静的解析を実行する
5. 元のコンテキストから移動後の関数を参照できるようにする
6. 元の関数を委譲関数に変更する
7. テストする
8. 元の関数に対して「関数のインライン化」の適用を検討する

### コード例

TODO: リンク貼る

## フィールドの移動

### 動機

- プログラミングの適切なデータ構造は重要な反面、適切なデータ構造を定義するのは難しい
- データ構造が正しくないとわかったら、すぐに変更することが重要
- あるレコードを関数に渡す際に、必ず別レコードのフィールドも渡す必要がある場合がある
  - まとめて関数に渡すデータは、通常なら同じレコードにまとめるべき
  - あるレコードを更新するたびに別レコードのフィールドも更新していることは、フィールドの場所が間違っていることを示唆している
  - これらはデータの構造を見直すきっかけになる

### 手順

1. 移動元のフィールドをカプセル化する
2. テストする
3. 移動先にフィールドを作成する
4. 静的解析を実行する
5. 移動元のオブジェクトから移動先のオブジェクトを参照できるようにする
6. 移動先のフィールドを使うようにアクセサを調整する
7. テストする
8. 移動元のフィールドを削除する
9. テストする

### コード例

TODO: リンク貼る

## ステートメントの関数内への移動

TODO:

### 動機

- プログラミングの適切なデータ構造は重要な反面、適切なデータ構造を定義するのは難しい
- データ構造が正しくないとわかったら、すぐに変更することが重要
- あるレコードを関数に渡す際に、必ず別レコードのフィールドも渡す必要がある場合がある
  - まとめて関数に渡すデータは、通常なら同じレコードにまとめるべき
  - あるレコードを更新するたびに別レコードのフィールドも更新していることは、フィールドの場所が間違っていることを示唆している
  - これらはデータの構造を見直すきっかけになる

### 手順

1. 移動元のフィールドをカプセル化する
2. テストする
3. 移動先にフィールドを作成する
4. 静的解析を実行する
5. 移動元のオブジェクトから移動先のオブジェクトを参照できるようにする
6. 移動先のフィールドを使うようにアクセサを調整する
7. テストする
8. 移動元のフィールドを削除する
9. テストする

### コード例

TODO: リンク貼る
