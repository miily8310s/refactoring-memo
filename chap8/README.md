# 第８章 特性の移動

- ここまで消化してきたリファクタリングは、プログラム要素の作成、削除、および名前の変更に関するもの
- リファクタリングのもう一つの重要な役割は、要素をコンテキスト間で移動させること
- 関数を移動させる
  - クラスやモジュール間では「**関数の移動**」
  - フィールドは「**フィールドの移動**」
- 個々のステートメントの移動
  - 「**ステートメントの関数内への移動**」で関数外から関数内に移動
  - 「**ステートメントの呼び出し側への移動**」で関数の外に移動
  - 「**ステートメントのスライド**」で関数内で移動
  - 「**関数呼び出しによるインラインコードの置き換え**」
    - 既存の関数と同じ処理をしているステートメントで重複を解除する
- ループに対して適用する
  - 「**ループの分離**」でループの仕事を一つだけにする
  - 「**パイプラインによるループの置き換え**」でループを完全に取り除く
- 「**デッドコードの削除**」

## 関数の移動

### 動機

- すべての関数はなんらかのコンテキストに置かれ、通常はなんらかのモジュールの形式を取る
- 関数を移動する最も直接的な理由は、その関数が存在するコンテキストの要素よりも他のコンテキストの要素を多く参照している場合
- 移動によって、関数をそれらの要素と一緒にすると、カプセル化が改善することがよくある
- 呼び出し元が存在する場所や、次の拡張時に呼び出したい場所に関数を移動することがある
- 関数の移動の判断はたいてい困難を伴う
  - その判断には、その関数の現在のコンテキストと移動先候補のコンテキストを調べる
- 新しいコンテキストが必要になるケースは多い
  - 関数群のクラスへの集約、クラスの抽出によって新しく作成する

### 手順

1. 移動対象の関数が現在のコンテキストで使用しているプログラム要素をすべて調べる。それらも移動するかも検討する
2. 選択した関数がポリモーフィックなメソッドか確認する
3. 関数を移動先のコンテキストにコピーする。新居となる移動先に関数が適合するように調整する
4. 静的解析を実行する
5. 元のコンテキストから移動後の関数を参照できるようにする
6. 元の関数を委譲関数に変更する
7. テストする
8. 元の関数に対して「関数のインライン化」の適用を検討する

### コード例

TODO: リンク貼る

## フィールドの移動

### 動機

- プログラミングの適切なデータ構造は重要な反面、適切なデータ構造を定義するのは難しい
- データ構造が正しくないとわかったら、すぐに変更することが重要
- あるレコードを関数に渡す際に、必ず別レコードのフィールドも渡す必要がある場合がある
  - まとめて関数に渡すデータは、通常なら同じレコードにまとめるべき
  - あるレコードを更新するたびに別レコードのフィールドも更新していることは、フィールドの場所が間違っていることを示唆している
  - これらはデータの構造を見直すきっかけになる

### 手順

1. 移動元のフィールドをカプセル化する
2. テストする
3. 移動先にフィールドを作成する
4. 静的解析を実行する
5. 移動元のオブジェクトから移動先のオブジェクトを参照できるようにする
6. 移動先のフィールドを使うようにアクセサを調整する
7. テストする
8. 移動元のフィールドを削除する
9. テストする

### コード例

TODO: リンク貼る

## ステートメントの関数内への移動

### 動機

- 重複の除去は、健全なコードを導くための最もすぐれた経験則の一つ
- 特定の関数を呼び出すたびに同じコードが実行されていたら、反復コードを関数自体に組み込む
- そうすることで、反復コードに将来変更が生じた場合でも、１箇所だけを修正すればすべての呼び出し側で使えるようになる

### 手順

1. 反復コードが移動先の関数呼び出しに隣接していない場合は、「ステートメントのスライド」を行って隣接させる
2. 移動元の関数の呼び出し元が移動先の関数だけだった場合は、移動元の関数からコードをカットし、移動先の関数にペーストして、テストを行い、残りの手順を無視する
3. 複数の呼び出し元がある場合は、いずれかの呼び出しに対して「関数の抽出」を行い、移動先の関数う呼び出しと移動したいステートメントを抽出する。名前は一時的なものにするが、簡単に grep できる名前にする
4. 他のすべての呼び出しを変更して、新しい関数を使うようにする。
5. 元の呼び出しのすべてで新しい関数を使うようになったら、「関数のインライン化」を行って元の関数を新しい関数に完全にインライン化し、元の関数を削除する
6. 「関数名の変更」を行って、新しい関数の名前を元の関数と同じ名前に変更する

### コード例

TODO: リンク貼る

## ステートメントの呼び出し側への移動

### 動機

- 関数は抽象化の基本的な構成要素
- ある時期に抽象化の境界線がいつの間にか変わっていることがある
- 境界線の変化に気づくのは、複数箇所で利用していた共通の振る舞いを一部の呼び出しに対してだけ変更する必要が出てきた場合
- そのとき、変更の対象となる振る舞いを、関数から呼び出し側に移動する必要がある
- その場合、「ステートメントのスライド」を行って、その振る舞いを関数の最初または最後に移動し、そのあとで「ステートメントの呼び出し側への移動」を行う

### 手順

1. 呼び出し側が一つか二つで、呼び出される関数が単純な場合は、その関数から最初の行をカットして、呼び出し側にペーストする。テストすれば終わり。
2. 呼び出し側が多い場合は、「移動したくない」すべてのステートメント群を対象に「関数の抽出」を行う。一時的な、しかし簡単に検索できる名前を付ける
3. 元の関数に対して「関数のインライン化」を行う
4. 抽出した関数に「関数宣言の変更」を行って元の名前に変更する

### コード例

TODO: リンク貼る

## 関数呼び出しによるインラインコードの置き換え

### 動機

- 関数は理解にも役立つ
  - 名前のついた関数は、コードの目的を説明できる
  - 重複の除去の点でも、同じコードを２回書く代わりに関数を呼び出すだけで済む
  - ロジックを変更する必要が生じた場合には、漏れなく変更するため類似したコードを調べる必要がなくなる
- 既存の関数と同じ処理をしているインラインコードがある場合、通常はそのインラインコードを関数呼び出しに置き換える

### 手順

1. インラインコードを既存の関数の呼び出しで置き換える
2. テストする

### コード例

TODO: リンク貼る

## ステートメントのスライド

### 動機

- 互いに関係する処理が並んでいると、コードは理解しやすくなる
- 同じデータ構造にアクセスするコードが複数行ある場合、他のデータ構造にアクセスするコードと混在させずに、それらだけをまとめるべき
- そのための最も素朴な方法が「ステートメントのスライド」
- まとめる作業は、別のリファクタリングの準備として行う
  - 主に「関数の抽出」において

### 手順

1. コード断片の移動先を特定する。移動元と移動先の間のステートメントを調べて、スライドする候補のコード断片によって鑑賞が起きないかを確認する。干渉が起きる場合は諦める
2. ソースからコード断片を切り取り、移動先の場所に貼り付ける
3. テストする

### コード例

TODO: リンク貼る

## ループの分離

### 動機

- 同じループの中で二つの異なる処理をしていると、ループを修正する際には、必ず両方の処理内容を理解しなければならなくなる
- ループを分離することで変更すべき処理だけを理解すればよい
- 結果としてループを２回実行することになる
- ただ、リファクタリングと最適化は分離されている
  - 最適化はコードをきれいにした後に実施し、ループがボトルネックになっているなら簡単に元に戻せる

### 手順

1. ループをコピーする
2. 重複による副作用を特定して排除する
3. テストする

### コード例

TODO: リンク貼る
